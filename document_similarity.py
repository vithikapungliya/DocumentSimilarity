# -*- coding: utf-8 -*-
"""Document Similarity.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-PGG3umSNAtEVbMnwQpvK_CEiL3HiRlm
"""

import nltk

nltk.download('punkt')
nltk.download('averaged_perceptron_tagger')
nltk.download('wordnet')
from nltk.corpus import stopwords
nltk.download('stopwords')
nltk.download('omw-1.4')

import numpy as np
import nltk
from nltk.corpus import wordnet as wn
import pandas as pd


def convert_tag(tag):

    
    tag_dict = {'N': 'n', 'J': 'a', 'R': 'r', 'V': 'v'}
    try:
        return tag_dict[tag[0]]
    except KeyError:
        return None


def doc_to_synsets(doc):
    
    tokens = nltk.word_tokenize(doc) #Tokenizing
    pos_tags = nltk.pos_tag(tokens) #Position tags
    wn_tags = [convert_tag(x[1]) for x in pos_tags] #Mappimg from above function
    # If there is nothing in the synset for the token, it must be skipped! Therefore check that len of the synset is > 0!
    # Will return a list of lists of synsets - one list for each token!
    # Remember to use only the first match for each token! Hence wn.synsets(x,y)[0]!
    synset_list = [wn.synsets(x,y)[0] for x,y in zip(tokens, wn_tags) if len(wn.synsets(x,y))>0]
    #print(synset_list)
    return synset_list

def similarity_score(s1, s2):
    
    max_sim = []
    #print(s1)
    for syn in s1:
        #print(syn)
        sim = [syn.path_similarity(x) for x in s2 if syn.path_similarity(x) is not None]
        if sim:
            max_sim.append(max(sim))
    return np.mean(max_sim)



def document_path_similarity(doc1, doc2):
   

    synsets1 = doc_to_synsets(doc1)
    synsets2 = doc_to_synsets(doc2)

    return (similarity_score(synsets1, synsets2) + similarity_score(synsets2, synsets1)) / 2

def test_document_path_similarity():
    doc1 = """Illustrates the CPU Utilization metric and the
available RAM dynamically using a line chart and a pie
chart respectively. The charts are dynamic in nature and the
proposed application fetches real time information about the
aforementioned metrics from the userâ€™s system and updates
the charts with the new values every second."""

    doc2 = """Using a line chart and a pie chart, respectively, dynamically illustrates the CPU Utilization metric and the amount of RAM that is accessible. The suggested application retrieves real-time data about the aforementioned metrics from the user's system and updates the charts with the new values every second. The charts are dynamic in nature."""
    return document_path_similarity(doc1, doc2)

test_document_path_similarity()